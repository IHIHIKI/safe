(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AccountsManagerClient"] = factory();
	else
		root["AccountsManagerClient"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./AccountsManagerClient.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@nimiq/rpc/dist/rpc.umd.js":
/*!**************************************************!*\
  !*** ../node_modules/@nimiq/rpc/dist/rpc.umd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n     true ? factory(exports) :\n    undefined;\n}(this, (function (exports) { 'use strict';\n\n    class RandomUtils {\n        static generateRandomId() {\n            const array = new Uint32Array(1);\n            crypto.getRandomValues(array);\n            return array[0];\n        }\n    }\n\n    (function (ResponseStatus) {\n        ResponseStatus[\"OK\"] = \"ok\";\n        ResponseStatus[\"ERROR\"] = \"error\";\n    })(exports.ResponseStatus || (exports.ResponseStatus = {}));\n\n    /* tslint:disable:no-bitwise */\n    class Base64 {\n        // base64 is 4/3 + up to two characters of the original data\n        static byteLength(b64) {\n            const [validLength, placeHoldersLength] = Base64._getLengths(b64);\n            return Base64._byteLength(validLength, placeHoldersLength);\n        }\n        static decode(b64) {\n            Base64._initRevLookup();\n            const [validLength, placeHoldersLength] = Base64._getLengths(b64);\n            const arr = new Uint8Array(Base64._byteLength(validLength, placeHoldersLength));\n            let curByte = 0;\n            // if there are placeholders, only get up to the last complete 4 chars\n            const len = placeHoldersLength > 0 ? validLength - 4 : validLength;\n            let i = 0;\n            for (; i < len; i += 4) {\n                const tmp = (Base64._revLookup[b64.charCodeAt(i)] << 18) |\n                    (Base64._revLookup[b64.charCodeAt(i + 1)] << 12) |\n                    (Base64._revLookup[b64.charCodeAt(i + 2)] << 6) |\n                    Base64._revLookup[b64.charCodeAt(i + 3)];\n                arr[curByte++] = (tmp >> 16) & 0xFF;\n                arr[curByte++] = (tmp >> 8) & 0xFF;\n                arr[curByte++] = tmp & 0xFF;\n            }\n            if (placeHoldersLength === 2) {\n                const tmp = (Base64._revLookup[b64.charCodeAt(i)] << 2) |\n                    (Base64._revLookup[b64.charCodeAt(i + 1)] >> 4);\n                arr[curByte++] = tmp & 0xFF;\n            }\n            if (placeHoldersLength === 1) {\n                const tmp = (Base64._revLookup[b64.charCodeAt(i)] << 10) |\n                    (Base64._revLookup[b64.charCodeAt(i + 1)] << 4) |\n                    (Base64._revLookup[b64.charCodeAt(i + 2)] >> 2);\n                arr[curByte++] = (tmp >> 8) & 0xFF;\n                arr[curByte /*++ not needed*/] = tmp & 0xFF;\n            }\n            return arr;\n        }\n        static encode(uint8) {\n            const length = uint8.length;\n            const extraBytes = length % 3; // if we have 1 byte left, pad 2 bytes\n            const parts = [];\n            const maxChunkLength = 16383; // must be multiple of 3\n            // go through the array every three bytes, we'll deal with trailing stuff later\n            for (let i = 0, len2 = length - extraBytes; i < len2; i += maxChunkLength) {\n                parts.push(Base64._encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n            }\n            // pad the end with zeros, but make sure to not forget the extra bytes\n            if (extraBytes === 1) {\n                const tmp = uint8[length - 1];\n                parts.push(Base64._lookup[tmp >> 2] +\n                    Base64._lookup[(tmp << 4) & 0x3F] +\n                    '==');\n            }\n            else if (extraBytes === 2) {\n                const tmp = (uint8[length - 2] << 8) + uint8[length - 1];\n                parts.push(Base64._lookup[tmp >> 10] +\n                    Base64._lookup[(tmp >> 4) & 0x3F] +\n                    Base64._lookup[(tmp << 2) & 0x3F] +\n                    '=');\n            }\n            return parts.join('');\n        }\n        static encodeUrl(buffer) {\n            return Base64.encode(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n        }\n        static decodeUrl(base64) {\n            return Base64.decode(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '='));\n        }\n        static _initRevLookup() {\n            if (Base64._revLookup.length !== 0)\n                return;\n            Base64._revLookup = [];\n            for (let i = 0, len = Base64._lookup.length; i < len; i++) {\n                Base64._revLookup[Base64._lookup.charCodeAt(i)] = i;\n            }\n            // Support decoding URL-safe base64 strings, as Node.js does.\n            // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n            Base64._revLookup['-'.charCodeAt(0)] = 62;\n            Base64._revLookup['_'.charCodeAt(0)] = 63;\n        }\n        static _getLengths(b64) {\n            const length = b64.length;\n            if (length % 4 > 0) {\n                throw new Error('Invalid string. Length must be a multiple of 4');\n            }\n            // Trim off extra bytes after placeholder bytes are found\n            // See: https://github.com/beatgammit/base64-js/issues/42\n            let validLength = b64.indexOf('=');\n            if (validLength === -1)\n                validLength = length;\n            const placeHoldersLength = validLength === length ? 0 : 4 - (validLength % 4);\n            return [validLength, placeHoldersLength];\n        }\n        static _byteLength(validLength, placeHoldersLength) {\n            return ((validLength + placeHoldersLength) * 3 / 4) - placeHoldersLength;\n        }\n        static _tripletToBase64(num) {\n            return Base64._lookup[num >> 18 & 0x3F] +\n                Base64._lookup[num >> 12 & 0x3F] +\n                Base64._lookup[num >> 6 & 0x3F] +\n                Base64._lookup[num & 0x3F];\n        }\n        static _encodeChunk(uint8, start, end) {\n            const output = [];\n            for (let i = start; i < end; i += 3) {\n                const tmp = ((uint8[i] << 16) & 0xFF0000) +\n                    ((uint8[i + 1] << 8) & 0xFF00) +\n                    (uint8[i + 2] & 0xFF);\n                output.push(Base64._tripletToBase64(tmp));\n            }\n            return output.join('');\n        }\n    }\n    Base64._lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    Base64._revLookup = [];\n\n    var ExtraJSONTypes;\n    (function (ExtraJSONTypes) {\n        ExtraJSONTypes[ExtraJSONTypes[\"UINT8_ARRAY\"] = 0] = \"UINT8_ARRAY\";\n    })(ExtraJSONTypes || (ExtraJSONTypes = {}));\n    class JSONUtils {\n        static stringify(value) {\n            return JSON.stringify(value, JSONUtils._jsonifyType);\n        }\n        static parse(value) {\n            return JSON.parse(value, JSONUtils._parseType);\n        }\n        static _parseType(key, value) {\n            if (value && value.hasOwnProperty &&\n                value.hasOwnProperty(JSONUtils.TYPE_SYMBOL) && value.hasOwnProperty(JSONUtils.VALUE_SYMBOL)) {\n                switch (value[JSONUtils.TYPE_SYMBOL]) {\n                    case ExtraJSONTypes.UINT8_ARRAY:\n                        return Base64.decode(value[JSONUtils.VALUE_SYMBOL]);\n                }\n            }\n            return value;\n        }\n        static _jsonifyType(key, value) {\n            if (value instanceof Uint8Array) {\n                return JSONUtils._typedObject(ExtraJSONTypes.UINT8_ARRAY, Base64.encode(value));\n            }\n            return value;\n        }\n        static _typedObject(type, value) {\n            const obj = {};\n            obj[JSONUtils.TYPE_SYMBOL] = type;\n            obj[JSONUtils.VALUE_SYMBOL] = value;\n            return obj;\n        }\n    }\n    JSONUtils.TYPE_SYMBOL = '__';\n    JSONUtils.VALUE_SYMBOL = 'v';\n\n    class RequestIdStorage {\n        /**\n         * @param {boolean} [storeState=true] Whether to store state in sessionStorage\n         */\n        constructor(storeState = true) {\n            this._store = storeState ? window.sessionStorage : null;\n            this._validIds = new Map();\n            if (storeState) {\n                this._restoreIds();\n            }\n        }\n        static _decodeIds(ids) {\n            const obj = JSONUtils.parse(ids);\n            const validIds = new Map();\n            for (const key of Object.keys(obj)) {\n                const integerKey = parseInt(key, 10);\n                validIds.set(isNaN(integerKey) ? key : integerKey, obj[key]);\n            }\n            return validIds;\n        }\n        has(id) {\n            return this._validIds.has(id);\n        }\n        getCommand(id) {\n            const result = this._validIds.get(id);\n            return result ? result[0] : null;\n        }\n        getState(id) {\n            const result = this._validIds.get(id);\n            return result ? result[1] : null;\n        }\n        add(id, command, state = null) {\n            this._validIds.set(id, [command, state]);\n            this._storeIds();\n        }\n        remove(id) {\n            this._validIds.delete(id);\n            this._storeIds();\n        }\n        clear() {\n            this._validIds.clear();\n            if (this._store) {\n                this._store.removeItem(RequestIdStorage.KEY);\n            }\n        }\n        _encodeIds() {\n            const obj = Object.create(null);\n            for (const [key, value] of this._validIds) {\n                obj[key] = value;\n            }\n            return JSONUtils.stringify(obj);\n        }\n        _restoreIds() {\n            const requests = this._store.getItem(RequestIdStorage.KEY);\n            if (requests) {\n                this._validIds = RequestIdStorage._decodeIds(requests);\n            }\n        }\n        _storeIds() {\n            if (this._store) {\n                this._store.setItem(RequestIdStorage.KEY, this._encodeIds());\n            }\n        }\n    }\n    RequestIdStorage.KEY = 'rpcRequests';\n\n    class UrlRpcEncoder {\n        static receiveRedirectCommand(url) {\n            // Need referrer for origin check\n            if (!document.referrer)\n                return null;\n            // Parse query\n            const params = new URLSearchParams(url.search);\n            const referrer = new URL(document.referrer);\n            // Ignore messages without a command\n            if (!params.has('command'))\n                return null;\n            // Ignore messages without an ID\n            if (!params.has('id'))\n                return null;\n            // Ignore messages without a valid return path\n            if (!params.has('returnURL'))\n                return null;\n            // Only allow returning to same origin\n            const returnURL = new URL(params.get('returnURL'));\n            if (returnURL.origin !== referrer.origin)\n                return null;\n            // Parse args\n            let args = [];\n            if (params.has('args')) {\n                try {\n                    args = JSONUtils.parse(params.get('args'));\n                }\n                catch (e) {\n                    // Do nothing\n                }\n            }\n            args = Array.isArray(args) ? args : [];\n            return {\n                origin: referrer.origin,\n                data: {\n                    id: parseInt(params.get('id'), 10),\n                    command: params.get('command'),\n                    args,\n                },\n                returnURL: params.get('returnURL'),\n            };\n        }\n        /**\n         * @param {URL|Location} url\n         * @return {{origin:string, data:{id:number, status:string, result:*}}}\n         */\n        static receiveRedirectResponse(url) {\n            // Need referrer for origin check\n            if (!document.referrer)\n                return null;\n            // Parse query\n            const params = new URLSearchParams(url.search);\n            const referrer = new URL(document.referrer);\n            // Ignore messages without a status\n            if (!params.has('status'))\n                return null;\n            // Ignore messages without an ID\n            if (!params.has('id'))\n                return null;\n            // Ignore messages without a result\n            if (!params.has('result'))\n                return null;\n            // Parse result\n            const result = JSONUtils.parse(params.get('result'));\n            const status = params.get('status') === exports.ResponseStatus.OK ? exports.ResponseStatus.OK : exports.ResponseStatus.ERROR;\n            return {\n                origin: referrer.origin,\n                data: {\n                    id: parseInt(params.get('id'), 10),\n                    status,\n                    result,\n                },\n            };\n        }\n        static prepareRedirectReply(state, status, result) {\n            const params = new URLSearchParams();\n            params.set('status', status);\n            params.set('result', JSONUtils.stringify(result));\n            params.set('id', state.id.toString());\n            // TODO: what if it already includes a query string\n            return `${state.returnURL}?${params.toString()}`;\n        }\n        static prepareRedirectInvocation(targetURL, id, returnURL, command, args) {\n            const params = new URLSearchParams();\n            params.set('id', id.toString());\n            params.set('returnURL', returnURL);\n            params.set('command', command);\n            if (Array.isArray(args)) {\n                params.set('args', JSONUtils.stringify(args));\n            }\n            // TODO: what if it already includes a query string\n            return `${targetURL}?${params.toString()}`;\n        }\n    }\n\n    class RpcClient {\n        constructor(allowedOrigin, storeState = false) {\n            this._allowedOrigin = allowedOrigin;\n            this._waitingRequests = new RequestIdStorage(storeState);\n            this._responseHandlers = new Map();\n        }\n        onResponse(command, resolve, reject) {\n            this._responseHandlers.set(command, { resolve, reject });\n        }\n        _receive(message) {\n            // Discard all messages from unwanted sources\n            // or which are not replies\n            // or which are not from the correct origin\n            if (!message.data\n                || !message.data.status\n                || !message.data.id\n                || (this._allowedOrigin !== '*' && message.origin !== this._allowedOrigin))\n                return;\n            const data = message.data;\n            // Response handlers by id have priority to more general ones by command\n            let callback;\n            if (this._responseHandlers.has(data.id)) {\n                callback = this._responseHandlers.get(data.id);\n            }\n            else {\n                const command = this._waitingRequests.getCommand(data.id);\n                if (command) {\n                    callback = this._responseHandlers.get(command);\n                }\n            }\n            const state = this._waitingRequests.getState(data.id);\n            if (callback) {\n                this._waitingRequests.remove(data.id);\n                console.debug('RpcClient RECEIVE', data);\n                if (data.status === exports.ResponseStatus.OK) {\n                    callback.resolve(data.result, data.id, state);\n                }\n                else if (data.status === exports.ResponseStatus.ERROR) {\n                    const error = new Error(data.result.message);\n                    if (data.result.stack) {\n                        error.stack = data.result.stack;\n                    }\n                    callback.reject(error, data.id, state);\n                }\n            }\n            else {\n                console.warn('Unknown RPC response:', data);\n            }\n        }\n    }\n    class PostMessageRpcClient extends RpcClient {\n        constructor(targetWindow, allowedOrigin) {\n            super(allowedOrigin);\n            this._target = targetWindow;\n            this._connected = false;\n            this._receiveListener = this._receive.bind(this);\n        }\n        async init() {\n            await this._connect();\n            window.addEventListener('message', this._receiveListener);\n        }\n        async call(command, ...args) {\n            if (!this._connected)\n                throw new Error('Client is not connected, call init first');\n            return new Promise((resolve, reject) => {\n                const obj = {\n                    command,\n                    args,\n                    id: RandomUtils.generateRandomId(),\n                };\n                // Store the request resolvers\n                this._responseHandlers.set(obj.id, { resolve, reject });\n                this._waitingRequests.add(obj.id, command);\n                // Periodically check if recepient window is still open\n                const checkIfServerWasClosed = () => {\n                    if (this._target.closed) {\n                        reject(new Error('window was closed'));\n                    }\n                    setTimeout(checkIfServerWasClosed, 500);\n                };\n                setTimeout(checkIfServerWasClosed, 500);\n                console.debug('RpcClient REQUEST', command, args);\n                this._target.postMessage(obj, this._allowedOrigin);\n            });\n        }\n        close() {\n            window.removeEventListener('message', this._receiveListener);\n        }\n        _connect() {\n            return new Promise((resolve, reject) => {\n                /**\n                 * @param {MessageEvent} message\n                 */\n                const connectedListener = (message) => {\n                    const { source, origin, data } = message;\n                    if (source !== this._target\n                        || data.status !== exports.ResponseStatus.OK\n                        || data.result !== 'pong'\n                        || data.id !== 1\n                        || (this._allowedOrigin !== '*' && origin !== this._allowedOrigin))\n                        return;\n                    // Debugging printouts\n                    if (data.result.stack) {\n                        const error = new Error(data.result.message);\n                        error.stack = data.result.stack;\n                        console.error(error);\n                    }\n                    window.removeEventListener('message', connectedListener);\n                    this._connected = true;\n                    console.log('RpcClient: Connection established');\n                    window.addEventListener('message', this._receiveListener);\n                    resolve(true);\n                };\n                window.addEventListener('message', connectedListener);\n                let connectTimer = 0;\n                const timeoutTimer = setTimeout(() => {\n                    window.removeEventListener('message', connectedListener);\n                    clearTimeout(connectTimer);\n                    reject(new Error('Connection timeout'));\n                }, 10 * 1000);\n                /**\n                 * Send 'ping' command every second, until cancelled\n                 */\n                const tryToConnect = () => {\n                    if (this._connected) {\n                        clearTimeout(timeoutTimer);\n                        return;\n                    }\n                    try {\n                        this._target.postMessage({ command: 'ping', id: 1 }, this._allowedOrigin);\n                    }\n                    catch (e) {\n                        console.error(`postMessage failed: ${e}`);\n                    }\n                    // @ts-ignore\n                    connectTimer = setTimeout(tryToConnect, 1000);\n                };\n                // @ts-ignore\n                connectTimer = setTimeout(tryToConnect, 100);\n            });\n        }\n    }\n    class RedirectRpcClient extends RpcClient {\n        constructor(targetURL, allowedOrigin) {\n            super(allowedOrigin, /*storeState*/ true);\n            this._target = targetURL;\n        }\n        async init() {\n            const message = UrlRpcEncoder.receiveRedirectResponse(window.location);\n            if (message) {\n                this._receive(message);\n            }\n        }\n        /* tslint:disable:no-empty */\n        close() { }\n        call(returnURL, command, ...args) {\n            this.callAndSaveLocalState(returnURL, null, command, ...args);\n        }\n        callAndSaveLocalState(returnURL, state, command, ...args) {\n            const id = RandomUtils.generateRandomId();\n            const url = UrlRpcEncoder.prepareRedirectInvocation(this._target, id, returnURL, command, args);\n            this._waitingRequests.add(id, command, state);\n            console.debug('RpcClient REQUEST', command, args);\n            window.location.href = url;\n        }\n    }\n\n    class State {\n        get id() {\n            return this._id;\n        }\n        get origin() {\n            return this._origin;\n        }\n        get data() {\n            return this._data;\n        }\n        get returnURL() {\n            return this._returnURL;\n        }\n        get source() {\n            return this._source;\n        }\n        static fromJSON(json) {\n            const obj = JSON.parse(json);\n            return new State(obj);\n        }\n        constructor(message) {\n            if (!message.data.id)\n                throw Error('Missing id');\n            this._origin = message.origin;\n            this._id = message.data.id;\n            this._postMessage = 'source' in message && !('returnURL' in message);\n            this._returnURL = 'returnURL' in message ? message.returnURL : null;\n            this._data = message.data;\n            this._source = 'source' in message ? message.source : null;\n        }\n        toJSON() {\n            const obj = {\n                origin: this._origin,\n                data: this._data,\n            };\n            if (this._postMessage) {\n                if (this._source === window.opener) {\n                    obj.source = 'opener';\n                }\n                else if (this._source === window.parent) {\n                    obj.source = 'parent';\n                }\n                else {\n                    obj.source = null;\n                }\n            }\n            else {\n                obj.returnURL = this._returnURL;\n            }\n            return JSON.stringify(obj);\n        }\n        reply(status, result) {\n            console.debug('RpcServer REPLY', result);\n            if (status === exports.ResponseStatus.ERROR) {\n                // serialize error objects\n                result = typeof result === 'object'\n                    ? { message: result.message, stack: result.stack }\n                    : { message: result };\n            }\n            if (this._postMessage) {\n                // Send via postMessage (e.g., popup)\n                let target;\n                // If source is given, choose accordingly\n                if (this._source) {\n                    if (this._source === 'opener') {\n                        target = window.opener;\n                    }\n                    else if (this._source === 'parent') {\n                        target = window.parent;\n                    }\n                    else {\n                        target = this._source;\n                    }\n                }\n                else {\n                    // Else guess\n                    target = window.opener || window.parent;\n                }\n                target.postMessage({\n                    status,\n                    result,\n                    id: this.id,\n                }, this.origin);\n            }\n            else if (this._returnURL) {\n                // Send via top-level navigation\n                window.location.href = UrlRpcEncoder.prepareRedirectReply(this, status, result);\n            }\n        }\n    }\n\n    class RpcServer {\n        static _ok(state, result) {\n            state.reply(exports.ResponseStatus.OK, result);\n        }\n        static _error(state, error) {\n            state.reply(exports.ResponseStatus.ERROR, error);\n        }\n        constructor(allowedOrigin) {\n            this._allowedOrigin = allowedOrigin;\n            this._responseHandlers = new Map();\n            this._responseHandlers.set('ping', () => 'pong');\n            this._receiveListener = this._receive.bind(this);\n        }\n        onRequest(command, fn) {\n            this._responseHandlers.set(command, fn);\n        }\n        init() {\n            window.addEventListener('message', this._receiveListener);\n            this._receiveRedirect();\n        }\n        close() {\n            window.removeEventListener('message', this._receiveListener);\n        }\n        _receiveRedirect() {\n            const message = UrlRpcEncoder.receiveRedirectCommand(window.location);\n            if (message) {\n                this._receive(message);\n            }\n        }\n        _receive(message) {\n            let state = null;\n            try {\n                state = new State(message);\n                // Cannot reply to a message that has no source window or return URL\n                if (!('source' in message) && !('returnURL' in message))\n                    return;\n                // Ignore messages without a command\n                if (!('command' in state.data)) {\n                    return;\n                }\n                if (this._allowedOrigin !== '*' && message.origin !== this._allowedOrigin) {\n                    throw new Error('Unauthorized');\n                }\n                const args = message.data.args && Array.isArray(message.data.args) ? message.data.args : [];\n                // Test if request calls a valid handler with the correct number of arguments\n                if (!this._responseHandlers.has(state.data.command)) {\n                    throw new Error(`Unknown command: ${state.data.command}`);\n                }\n                const requestedMethod = this._responseHandlers.get(state.data.command);\n                // Do not include state argument\n                if (Math.max(requestedMethod.length - 1, 0) < args.length) {\n                    throw new Error(`Too many arguments passed: ${message}`);\n                }\n                console.debug('RpcServer ACCEPT', state.data);\n                // Call method\n                const result = requestedMethod(state, ...args);\n                // If a value is returned, we take care of the reply,\n                // otherwise we assume the handler to do the reply when appropriate.\n                if (result instanceof Promise) {\n                    result\n                        .then((finalResult) => {\n                        if (finalResult !== undefined) {\n                            RpcServer._ok(state, finalResult);\n                        }\n                    })\n                        .catch((error) => RpcServer._error(state, error));\n                }\n                else if (result !== undefined) {\n                    RpcServer._ok(state, result);\n                }\n            }\n            catch (error) {\n                if (state) {\n                    RpcServer._error(state, error);\n                }\n            }\n        }\n    }\n\n    exports.RpcClient = RpcClient;\n    exports.PostMessageRpcClient = PostMessageRpcClient;\n    exports.RedirectRpcClient = RedirectRpcClient;\n    exports.RpcServer = RpcServer;\n    exports.State = State;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack://AccountsManagerClient/../node_modules/@nimiq/rpc/dist/rpc.umd.js?");

/***/ }),

/***/ "../src/lib/RequestTypes.ts":
/*!**********************************!*\
  !*** ../src/lib/RequestTypes.ts ***!
  \**********************************/
/*! exports provided: RequestType, AccountsRequest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequestType\", function() { return RequestType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AccountsRequest\", function() { return AccountsRequest; });\nvar RequestType;\n(function (RequestType) {\n    RequestType[\"LIST\"] = \"list\";\n    RequestType[\"CHECKOUT\"] = \"checkout\";\n    RequestType[\"SIGNUP\"] = \"signup\";\n    RequestType[\"LOGIN\"] = \"login\";\n})(RequestType || (RequestType = {}));\nclass AccountsRequest {\n    static parse(request, requestType) {\n        switch (request.kind || requestType) {\n            case RequestType.CHECKOUT:\n                // Because the switch statement is not definitely using 'request.kind' as the condition,\n                // Typescript cannot infer what type the request variable is from the control flow,\n                // thus we need to force-cast it here:\n                request = request;\n                return {\n                    kind: RequestType.CHECKOUT,\n                    appName: request.appName,\n                    recipient: new Nimiq.Address(request.recipient),\n                    recipientType: request.recipientType,\n                    value: request.value,\n                    fee: request.fee,\n                    data: request.data,\n                    flags: request.flags,\n                    networkId: request.networkId,\n                };\n            case RequestType.SIGNUP:\n                request = request;\n                return {\n                    kind: RequestType.SIGNUP,\n                    appName: request.appName,\n                };\n            case RequestType.LOGIN:\n                request = request;\n                return {\n                    kind: RequestType.LOGIN,\n                    appName: request.appName,\n                };\n            default:\n                return null;\n        }\n    }\n    static raw(request) {\n        switch (request.kind) {\n            case RequestType.CHECKOUT:\n                return {\n                    kind: RequestType.CHECKOUT,\n                    appName: request.appName,\n                    recipient: request.recipient.serialize(),\n                    recipientType: request.recipientType,\n                    value: request.value,\n                    fee: request.fee,\n                    data: request.data,\n                    flags: request.flags,\n                    networkId: request.networkId,\n                };\n            case RequestType.SIGNUP:\n                return {\n                    kind: RequestType.SIGNUP,\n                    appName: request.appName,\n                };\n            case RequestType.LOGIN:\n                return {\n                    kind: RequestType.LOGIN,\n                    appName: request.appName,\n                };\n            default:\n                return null;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://AccountsManagerClient/../src/lib/RequestTypes.ts?");

/***/ }),

/***/ "./AccountsManagerClient.ts":
/*!**********************************!*\
  !*** ./AccountsManagerClient.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AccountsManagerClient; });\n/* harmony import */ var _RequestBehavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestBehavior */ \"./RequestBehavior.ts\");\n/* harmony import */ var _src_lib_RequestTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/lib/RequestTypes */ \"../src/lib/RequestTypes.ts\");\n\n// import {RedirectRpcClient} from '@nimiq/rpc';\n\nclass AccountsManagerClient {\n    // private readonly _redirectClient: RedirectRpcClient;\n    // private readonly _observable: Nimiq.Observable;\n    constructor(endpoint = AccountsManagerClient.DEFAULT_ENDPOINT) {\n        this._endpoint = endpoint;\n        this._popupBehavior = new _RequestBehavior__WEBPACK_IMPORTED_MODULE_0__[\"PopupRequestBehavior\"](`left=${window.innerWidth / 2 - 500},top=50,width=1000,height=900,location=yes,dependent=yes`);\n        this._iframeBehavior = new _RequestBehavior__WEBPACK_IMPORTED_MODULE_0__[\"IFrameRequestBehavior\"]();\n        // this._redirectClient = new RedirectRpcClient('', RequestBehavior.getAllowedOrigin(this._endpoint));\n        // this._redirectClient.onResponse('request', this._onResolve.bind(this), this._onReject.bind(this));\n        // this._observable = new Nimiq.Observable();\n    }\n    // public init() {\n    //     return this._redirectClient.init();\n    // }\n    // public on(command: RequestType, resolve: (...args: any[]) => any, reject: (...args: any[]) => any) {\n    //     this._observable.on(`${command}-resolve`, resolve);\n    //     this._observable.on(`${command}-reject`, reject);\n    // }\n    signup(request, requestBehavior = this._popupBehavior) {\n        return this._request(requestBehavior, _src_lib_RequestTypes__WEBPACK_IMPORTED_MODULE_1__[\"RequestType\"].SIGNUP, [request]);\n    }\n    checkout(request, requestBehavior = this._popupBehavior) {\n        return this._request(requestBehavior, _src_lib_RequestTypes__WEBPACK_IMPORTED_MODULE_1__[\"RequestType\"].CHECKOUT, [request]);\n    }\n    login(request, requestBehavior = this._popupBehavior) {\n        return this._request(requestBehavior, _src_lib_RequestTypes__WEBPACK_IMPORTED_MODULE_1__[\"RequestType\"].LOGIN, [request]);\n    }\n    list(requestBehavior = this._iframeBehavior) {\n        return this._request(requestBehavior, _src_lib_RequestTypes__WEBPACK_IMPORTED_MODULE_1__[\"RequestType\"].LIST, []);\n    }\n    // END API\n    /* PRIVATE METHODS */\n    _request(behavior, command, args) {\n        return behavior.request(this._endpoint, command, args);\n    }\n}\nAccountsManagerClient.DEFAULT_ENDPOINT = '../src';\n\n\n//# sourceURL=webpack://AccountsManagerClient/./AccountsManagerClient.ts?");

/***/ }),

/***/ "./RequestBehavior.ts":
/*!****************************!*\
  !*** ./RequestBehavior.ts ***!
  \****************************/
/*! exports provided: RequestBehavior, RedirectRequestBehavior, PopupRequestBehavior, IFrameRequestBehavior */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequestBehavior\", function() { return RequestBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedirectRequestBehavior\", function() { return RedirectRequestBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PopupRequestBehavior\", function() { return PopupRequestBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IFrameRequestBehavior\", function() { return IFrameRequestBehavior; });\n/* harmony import */ var _nimiq_rpc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nimiq/rpc */ \"../node_modules/@nimiq/rpc/dist/rpc.umd.js\");\n/* harmony import */ var _nimiq_rpc__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_nimiq_rpc__WEBPACK_IMPORTED_MODULE_0__);\n\nclass RequestBehavior {\n    static getAllowedOrigin(endpoint) {\n        // FIXME derive from endpoint url\n        return '*';\n    }\n    constructor(type) {\n        this._type = type;\n    }\n    async request(endpoint, command, args) {\n        throw new Error('Not implemented');\n    }\n    get type() {\n        return this._type;\n    }\n}\nvar BehaviorType;\n(function (BehaviorType) {\n    BehaviorType[BehaviorType[\"REDIRECT\"] = 0] = \"REDIRECT\";\n    BehaviorType[BehaviorType[\"POPUP\"] = 1] = \"POPUP\";\n    BehaviorType[BehaviorType[\"IFRAME\"] = 2] = \"IFRAME\";\n})(BehaviorType || (BehaviorType = {}));\nclass RedirectRequestBehavior extends RequestBehavior {\n    static withLocalState(localState) {\n        return new RedirectRequestBehavior(undefined, localState);\n    }\n    constructor(targetUrl, localState) {\n        super(BehaviorType.REDIRECT);\n        const location = window.location;\n        this._targetUrl = targetUrl\n            || `${location.protocol}//${location.hostname}:${location.port}${location.pathname}`;\n        this._localState = localState || {};\n        // Reject local state with reserved property.\n        if (typeof this._localState.__command !== 'undefined') {\n            throw new Error('Invalid localState: Property \\'__command\\' is reserved');\n        }\n    }\n    async request(endpoint, command, args) {\n        const origin = RequestBehavior.getAllowedOrigin(endpoint);\n        const client = new _nimiq_rpc__WEBPACK_IMPORTED_MODULE_0__[\"RedirectRpcClient\"](endpoint, origin);\n        await client.init();\n        const state = Object.assign({ __command: command }, this._localState);\n        console.log('state', state);\n        client.callAndSaveLocalState(this._targetUrl, state, command, ...args);\n    }\n}\nclass PopupRequestBehavior extends RequestBehavior {\n    constructor(options = PopupRequestBehavior.DEFAULT_OPTIONS) {\n        super(BehaviorType.POPUP);\n        this._options = options;\n    }\n    async request(endpoint, command, args) {\n        const origin = RequestBehavior.getAllowedOrigin(endpoint);\n        const popup = this.createPopup(endpoint);\n        const client = new _nimiq_rpc__WEBPACK_IMPORTED_MODULE_0__[\"PostMessageRpcClient\"](popup, origin);\n        await client.init();\n        try {\n            const result = await client.call(command, ...args);\n            client.close();\n            // popup.close(); // Do not close to enable the popup displaying the success page\n            return result;\n        }\n        catch (e) {\n            client.close();\n            popup.close();\n            throw e;\n        }\n    }\n    createPopup(url) {\n        const popup = window.open(url, 'NimiqAccounts', this._options);\n        if (!popup) {\n            throw new Error('Failed to open popup');\n        }\n        return popup;\n    }\n}\nPopupRequestBehavior.DEFAULT_OPTIONS = '';\nclass IFrameRequestBehavior extends RequestBehavior {\n    constructor() {\n        super(BehaviorType.IFRAME);\n        this._iframe = null;\n        this._client = null;\n    }\n    async request(endpoint, command, args) {\n        if (this._iframe && this._iframe.src !== `${endpoint}/iframe.html`) {\n            throw new Error('Accounts Manager iframe is already opened with another endpoint');\n        }\n        const origin = RequestBehavior.getAllowedOrigin(endpoint);\n        if (!this._iframe) {\n            this._iframe = await this.createIFrame(endpoint);\n        }\n        if (!this._iframe.contentWindow) {\n            throw new Error(`IFrame contentWindow is ${typeof this._iframe.contentWindow}`);\n        }\n        if (!this._client) {\n            this._client = new _nimiq_rpc__WEBPACK_IMPORTED_MODULE_0__[\"PostMessageRpcClient\"](this._iframe.contentWindow, origin);\n            await this._client.init();\n        }\n        return await this._client.call(command, ...args);\n    }\n    async createIFrame(endpoint) {\n        return new Promise((resolve, reject) => {\n            const $iframe = document.createElement('iframe');\n            $iframe.name = 'NimiqAccountsIFrame';\n            $iframe.style.display = 'none';\n            document.body.appendChild($iframe);\n            $iframe.src = `${endpoint}/iframe.html`;\n            $iframe.onload = () => resolve($iframe);\n            $iframe.onerror = reject;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://AccountsManagerClient/./RequestBehavior.ts?");

/***/ })

/******/ });
});
